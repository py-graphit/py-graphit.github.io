

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>graphit.graph_combinatorial package &mdash; Graphit 0.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="graphit.graph_io package" href="graphit.graph_io.html" />
    <link rel="prev" title="graphit.graph_axis package" href="graphit.graph_axis.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Graphit
          

          
            
            <img src="_static/graphit-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="graphit.html">graphit API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="graphit.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_algorithms.html">graphit.graph_algorithms package</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_axis.html">graphit.graph_axis package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">graphit.graph_combinatorial package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-graphit.graph_combinatorial.graph_setlike_operations">graphit.graph_combinatorial.graph_setlike_operations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-graphit.graph_combinatorial.graph_split_join_operations">graphit.graph_combinatorial.graph_split_join_operations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-graphit.graph_combinatorial.graph_update_operations">graphit.graph_combinatorial.graph_update_operations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-graphit.graph_combinatorial">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_io.html">graphit.graph_io package</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_model_classes.html">graphit.graph_model_classes package</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_query.html">graphit.graph_query package</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_storage_drivers.html">graphit.graph_storage_drivers package</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphit.graph_utils.html">graphit.graph_utils package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit.graph">graphit.graph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit.graph_exceptions">graphit.graph_exceptions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit.graph_helpers">graphit.graph_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit.graph_mixin">graphit.graph_mixin module</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit.graph_networkx">graphit.graph_networkx module</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit.graph_orm">graphit.graph_orm module</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphit.html#module-graphit">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Graphit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="graphit.html">graphit package</a> &raquo;</li>
        
      <li>graphit.graph_combinatorial package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/graphit.graph_combinatorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
            
  <div class="section" id="graphit-graph-combinatorial-package">
<h1>graphit.graph_combinatorial package<a class="headerlink" href="#graphit-graph-combinatorial-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-graphit.graph_combinatorial.graph_setlike_operations">
<span id="graphit-graph-combinatorial-graph-setlike-operations-module"></span><h2>graphit.graph_combinatorial.graph_setlike_operations module<a class="headerlink" href="#module-graphit.graph_combinatorial.graph_setlike_operations" title="Permalink to this headline">¶</a></h2>
<p>file: graph_setlike_operations.py</p>
<p>Functions to perform Python [set-like](<a class="reference external" href="https://docs.python.org/3/library/">https://docs.python.org/3/library/</a>
stdtypes.html#set-types-set-frozenset) operation on graphs.</p>
<p>These functions aim to return a view-based result graph (subgraph) as often
as possible by checking if the input graphs share te same origin graph.
If returning a view is not possible or explicitly not requested the returned
graph is based on a deep copy of the first graph provided as argument to the
function.</p>
<p>The set-like combinatorial operations are based on (dis)-similarity in node
and edge ID’s regardless of the <cite>auto_nid</cite> setting.
Set-like operations based on node and/or edge attributes is possible by first
performing a node/edge query followed by the set operation.</p>
<p>A general concept in (graphit) Graphs is that nodes do not need to have edges
but edges cannot exist without their respective nodes. While union and
intersection operations will always return graphs that meet these requirements,
difference operations do not. If the difference between two graphs is an edge
returning that edge alone as Graph object without the corresponding nodes is
not allowed. Therefore, by default, the difference functions are node oriented.
In calculating the difference between a sub graph and its parent graph this
approach will result in a desired graph subtraction operation where the edges
linking sub graph and parent are removed.
However, these functions have a <cite>edge_diff</cite> flag that will switch the function
to calculate the edge oriented difference that will include nodes to return a
valid graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions do not update node and/or edge attributes in the
resulting graph as might be required in for instance a union or
intersection operation.</p>
</div>
<dl class="function">
<dt id="graphit.graph_combinatorial.graph_setlike_operations.graph_union">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_setlike_operations.</code><code class="sig-name descname">graph_union</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_setlike_operations.graph_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a graph with the union of the input graphs</p>
<p>The union represents the combined unique nodes and edges present in
the graphs. Similarity is based on ID.</p>
<p>Nodes and edges are added without updating the respective attributes.
The latter can be done by calling the <cite>update</cite> function afterwards.</p>
<p>If the graphs share a common origin graph and <cite>return_copy</cite> is False
the returned intersection graph will be a view on the origin, else it is
a new graph.
In both cases, the first graph in the argument list is used as basis
for the returned union graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>:py:list</em>) – graphs to return the union for</p></li>
<li><p><strong>return_copy</strong> (<em>:py:bool</em>) – force return a new graph as deep copy based on graph1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>union graph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:graphit:Graph</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>AttributeError, if arguments no instance of Graph class</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_setlike_operations.graph_intersection">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_setlike_operations.</code><code class="sig-name descname">graph_intersection</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em>, <em class="sig-param">return_copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_setlike_operations.graph_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a graph with the intersection in nodes and edges between the two
input graphs</p>
<p>The intersection represents the nodes and edges connecting them present
in both graphs. Node and edge similarity is based on ID.</p>
<p>If the graphs share a common origin graph and <cite>return_copy</cite> is False
the returned intersection graph will be a view on the origin, else it is
a new graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>:graphit:Graph</em>) – first graph</p></li>
<li><p><strong>graph2</strong> (<em>:graphit:Graph</em>) – second graph</p></li>
<li><p><strong>return_copy</strong> (<em>:py:bool</em>) – force return a new graph as deep copy based on graph1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>intersection graph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:graphit:Graph</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>AttributeError, if arguments no instance of Graph class</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_setlike_operations.graph_difference">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_setlike_operations.</code><code class="sig-name descname">graph_difference</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em>, <em class="sig-param">edge_diff=False</em>, <em class="sig-param">return_copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_setlike_operations.graph_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a graph with the difference in nodes and edges of <cite>graph1</cite> with
respect to <cite>graph2</cite>.</p>
<p>The difference represents the nodes and edges connecting them that are
present in <cite>graph1</cite> but not in <cite>graph2</cite>. Difference is based on ID.
The difference is node driven resulting in edges being removed when the
nodes on either end are removed. Use the <cite>edge_diff</cite> argument to switch
to an edge driven difference calculation,</p>
<p>If the graphs share a common origin graph and <cite>return_copy</cite> is False
the returned intersection graph will be a view on the origin, else it is
a new graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>:graphit:Graph</em>) – first graph</p></li>
<li><p><strong>graph2</strong> (<em>:graphit:Graph</em>) – second graph</p></li>
<li><p><strong>edge_diff</strong> (<em>:py:bool</em>) – switch from node to edge driven difference calculation</p></li>
<li><p><strong>return_copy</strong> (<em>:py:bool</em>) – force return a new graph as deep copy based on graph1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>difference graph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:graphit:Graph</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>AttributeError, if arguments no instance of Graph class</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_setlike_operations.graph_issubset">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_setlike_operations.</code><code class="sig-name descname">graph_issubset</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_setlike_operations.graph_issubset" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if graph1 is a subset of graph2 two in terms of nodes and edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>:graphit:Graph</em>) – first graph</p></li>
<li><p><strong>graph2</strong> (<em>:graphit:Graph</em>) – second graph</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>issubset or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:py:bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>AttributeError, if arguments no instance of Graph class</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_setlike_operations.graph_issuperset">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_setlike_operations.</code><code class="sig-name descname">graph_issuperset</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_setlike_operations.graph_issuperset" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if graph1 is a superset of graph2 two in terms of nodes and edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>:graphit:Graph</em>) – first graph</p></li>
<li><p><strong>graph2</strong> (<em>:graphit:Graph</em>) – second graph</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>issuperset or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:py:bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>AttributeError, if arguments no instance of Graph class</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_setlike_operations.graph_symmetric_difference">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_setlike_operations.</code><code class="sig-name descname">graph_symmetric_difference</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em>, <em class="sig-param">edge_diff=False</em>, <em class="sig-param">return_copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_setlike_operations.graph_symmetric_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new graph with the symmetric difference in nodes and edges of two
graphs.</p>
<p>The symmetric difference represents the nodes and edges connecting them
that are present in <cite>graph1</cite> but not in <cite>graph2</cite> and vice versa.
It is thus the opposite of the <cite>graph_intersection</cite>.
The difference is node driven resulting in edges being removed when the
nodes on either end are removed. Use the <cite>edge_diff</cite> argument to switch
to an edge driven difference calculation,</p>
<p>If the graphs share a common origin graph and <cite>return_copy</cite> is False
the returned intersection graph will be a view on the origin, else it is
a new graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>:graphit:Graph</em>) – first graph</p></li>
<li><p><strong>graph2</strong> (<em>:graphit:Graph</em>) – second graph</p></li>
<li><p><strong>edge_diff</strong> (<em>:py:bool</em>) – switch from node to edge driven difference calculation</p></li>
<li><p><strong>return_copy</strong> (<em>:py:bool</em>) – force return a new grpah as deep copy based on graph1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>symmetric difference graph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:graphit:Graph</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>AttributeError, if arguments no instance of Graph class</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-graphit.graph_combinatorial.graph_split_join_operations">
<span id="graphit-graph-combinatorial-graph-split-join-operations-module"></span><h2>graphit.graph_combinatorial.graph_split_join_operations module<a class="headerlink" href="#module-graphit.graph_combinatorial.graph_split_join_operations" title="Permalink to this headline">¶</a></h2>
<p>file: graph_split_join_operations.py</p>
<p>Functions to split or combine graphs.</p>
<dl class="function">
<dt id="graphit.graph_combinatorial.graph_split_join_operations.graph_join">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_split_join_operations.</code><code class="sig-name descname">graph_join</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em>, <em class="sig-param">links=None</em>, <em class="sig-param">run_node_new=True</em>, <em class="sig-param">run_edge_new=True</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_split_join_operations.graph_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Add graph2 as subgraph to graph1</p>
<p>All nodes and edges of graph 2 are added to graph 1. Final links between
nodes in graph 1 and newly added nodes of graph 2 are defined by the edges
in the <cite>links</cite> list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<a class="reference internal" href="graphit.graph_axis.html#graphit.graph_axis.graph_axis_class.GraphAxis" title="graphit.graph_axis.graph_axis_class.GraphAxis"><em>GraphAxis</em></a>) – graph to add to</p></li>
<li><p><strong>graph2</strong> (<a class="reference internal" href="graphit.graph_axis.html#graphit.graph_axis.graph_axis_class.GraphAxis" title="graphit.graph_axis.graph_axis_class.GraphAxis"><em>GraphAxis</em></a>) – graph added</p></li>
<li><p><strong>links</strong> (<em>:py:list</em>) – links between nodes in graph1 and graph2</p></li>
<li><p><strong>run_edge_new</strong> (<em>py:bool</em>) – run the custom initiation method (new method) of
the new edge once.</p></li>
<li><p><strong>run_node_new</strong> (<em>:py:bool</em>) – run the custom initiation method (new method) of
the new node once.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>node mapping</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:py:dict</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-graphit.graph_combinatorial.graph_update_operations">
<span id="graphit-graph-combinatorial-graph-update-operations-module"></span><h2>graphit.graph_combinatorial.graph_update_operations module<a class="headerlink" href="#module-graphit.graph_combinatorial.graph_update_operations" title="Permalink to this headline">¶</a></h2>
<p>file: graph_update_operations.py</p>
<p>Functions that return new graphs with updated nodes and edges including their
attributes based on node/edge ID’s.</p>
<p>These functions have equivalents in the <cite>graph_setlike_operations</cite> library
where the focus is on returning <cite>views</cite> as often as possible and attributes
are not updated.</p>
<dl class="function">
<dt id="graphit.graph_combinatorial.graph_update_operations.graph_add">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_update_operations.</code><code class="sig-name descname">graph_add</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_update_operations.graph_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add graphs together</p>
<p>Using the first graph as base graph, add all nodes and edges in the
remaining graphs to the first graph based on node and edge ID.
Attributes are updated for nodes and edges already in the graph one or
multiple times.
Node and edge attribute update can be switched on/off using the
<cite>update_node_attributes</cite> and <cite>update_edge_attributes</cite> respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>in case multiple graphs are added together that have overlapping
nodes or edges defining similar attributes the final value of the
attribute in the result graph equals the last input graph that
defines that attribute.</p>
</div>
<p>Please use the <cite>graph_setlike_operations.graph_union</cite> function to create a
union between input graphs that will not update attributes and return
<cite>views</cite> in case of a common origin graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will not create any new nodes or edges that are not
already available in on of the input graphs. This may yield a
result graph with isolated sub graphs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>:py:list</em>) – graphs to add together</p></li>
<li><p><strong>update_node_attributes</strong> (<em>:py:bool</em>) – update existing node attributes</p></li>
<li><p><strong>update_edge_attributes</strong> (<em>:py:bool</em>) – update existing edge attributes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new Graph joining input graphs</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:graphit:Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_update_operations.graph_subtract">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_update_operations.</code><code class="sig-name descname">graph_subtract</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_update_operations.graph_subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract the second graph from the first</p>
<p>Subtracting equals calculating the graph difference between graph1 and
graph2 using a node oriented difference and returning a copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>:graphit:Graph</em>) – first graph</p></li>
<li><p><strong>graph2</strong> (<em>:graphit:Graph</em>) – second graph</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new Graph with differences between graph1, graph2</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>:graphit:Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_update_operations.graph_update">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_update_operations.</code><code class="sig-name descname">graph_update</code><span class="sig-paren">(</span><em class="sig-param">graph1</em>, <em class="sig-param">graph2</em>, <em class="sig-param">update_edges=True</em>, <em class="sig-param">update_nodes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_update_operations.graph_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update graph1 with the content of graph2</p>
<p>Requires graph2 to be fully contained in graph1 based on graph topology
measured as equality between nodes and edges assessed by node and edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph1</strong> (<em>Graph</em>) – target graph</p></li>
<li><p><strong>graph2</strong> (<em>Graph</em>) – source graph</p></li>
<li><p><strong>update_edges</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) – update edge data</p></li>
<li><p><strong>update_nodes</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) – update node data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graphit.graph_combinatorial.graph_update_operations.graph_axis_update">
<code class="sig-prename descclassname">graphit.graph_combinatorial.graph_update_operations.</code><code class="sig-name descname">graph_axis_update</code><span class="sig-paren">(</span><em class="sig-param">graph</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#graphit.graph_combinatorial.graph_update_operations.graph_axis_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive update graph nodes from dictionary or other graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<a class="reference internal" href="graphit.graph_axis.html#graphit.graph_axis.graph_axis_class.GraphAxis" title="graphit.graph_axis.graph_axis_class.GraphAxis"><em>GraphAxis</em></a>) – graph to update</p></li>
<li><p><strong>data</strong> – dictionary or graph to update from</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-graphit.graph_combinatorial">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-graphit.graph_combinatorial" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
    <a href="https://github.com/py-graphit/py-graphit">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub">
    </a>

          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="graphit.graph_io.html" class="btn btn-neutral float-right" title="graphit.graph_io package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="graphit.graph_axis.html" class="btn btn-neutral float-left" title="graphit.graph_axis package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Marc van Dijk, VU University, Amsterdam

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>